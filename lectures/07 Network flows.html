<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Network flows</title>
<meta name="author" content="Adolfo De Unánue Adolfo De Unánue Adolfo De Unánue"/>
<meta name="description" content="Description
School specific teaching materials"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://revealjs.com/css/reveal.css"/>

<link rel="stylesheet" href="https://revealjs.com/css/theme/black.css" id="theme"/>

<link rel="stylesheet" href="./css/mozilla-light.css"/>

<link rel="stylesheet" href="./reveal.js/plugin/toc-progress/toc-progress.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/toc-style.css"/>

<link rel="stylesheet" href="./reveal.js/lib/font/source-sans-pro/source-sans-pro.css"/>

<link rel="stylesheet" href="./css/or.css"/>
<link rel="stylesheet" href="https://revealjs.com/lib/css/zenburn.css"/>
<link rel="stylesheet" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css"/>
<style>
/* Position computations of klipse get confused by reveal.js's scaling.
   Hence, scaling should be disabled with this code.  Fix height of code area
   with scrollbar (use overflow instead of overflow-y to restore CodeMirror
   setting afterwards): */
.reveal section pre { max-height: 70vh; height: auto; overflow: auto; }
/* Reset some reveal.js and oer-reveal settings: */
.reveal section pre .CodeMirror pre { font-size: 2em; box-shadow: none; width: auto; padding: 0.4em; display: block; overflow: visible; }
/* Enlarge cursor: */
.CodeMirror-cursor { border-left: 3px solid black; }
</style>
<script>
    window.klipse_settings = {
        selector: '.language-klipse',
        selector_eval_html: '.language-klipse-html',
        selector_eval_js: '.language-klipse-javascript',
        selector_eval_js: '.language-klipse-js',
        selector_eval_php: '.language-klipse-php',
        selector_eval_python_client: '.language-klipse-python',
        selector_eval_ruby: '.language-klipse-ruby',
        selector_eval_scheme: '.language-klipse-scheme',
        selector_sql: '.language-klipse-sql'
    };
</script>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://revealjs.com/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<meta name="description" content="Investigación de Operaciones 2020.">
<base target="_blank">
<base href="../">

          <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic,700italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
          <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400,700' rel='stylesheet' type='text/css'>
          <style type='text/css'>
             body {
                font-family: 'Source Sans Pro', sans-serif;
             }
             pre, code {
                font-family: 'Source Code Pro', monospace;
             }
          </style>
</head>
<body prefix="dc: http://purl.org/dc/elements/1.1/ dcterms: http://purl.org/dc/terms/ dcmitype: http://purl.org/dc/dcmitype/ cc: http://creativecommons.org/ns#" typeof="dcmitype:InteractiveResource">
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1 class="title">Network flows</h1><h2 class="author">Adolfo De Unánue Adolfo De Unánue Adolfo De Unánue</h2>
</section>
<section>
<section id="slide-orgecbfea0">
<h2 id="orgecbfea0">Introduction and Recap of Last Class</h2>
</section>
<section id="slide-org2852647">
<h3 id="org2852647">Anuncios</h3>
<form><ul>
<li>&#x2026;</li>

</ul></form>
</section>
<section id="slide-orgb65b66d">
<h3 id="orgb65b66d">Repaso de la última clase</h3>
</section>
<section id="slide-lectures/Introduction and Recap of Last Class/Outline">
<h3 id="lectures/Introduction and Recap of Last Class/Outline">Lecture Outline</h3>
</section>
</section>
<section>
<section id="slide-org6023aa5">
<h2 id="org6023aa5">Grafos</h2>

</section>
</section>
<section>
<section id="slide-org0259f5b">
<h2 id="org0259f5b">Conceptos</h2>
<form><ul>
<li>Otros nombres para el nodo son <span class="underline">vértices</span>, para los arcos, <span class="underline">aristas</span></li>
<li><b>Grafo dirigido</b> o <i>digrafo</i> Es un conjunto \(N\) de <span class="underline">nodos</span> y un conjunto \(A\) de
<span class="underline">arcos</span>, donde cada arco es un conjunto ordenado de un par de nodos, \(G(N,A)\).</li>
<li>\((n_1, n_2)\)   es un <span class="underline">arco saliente</span> de \(n_1\) a \(n_2\) y un <span class="underline">arco entrante</span>
de \(n_2\) a \(n_1\).</li>
<li>\(n_2\) es un <span class="underline">vecino</span> de \(n1\) si hay un arco de \(n_1\) a \(n_2\).</li>
<li>Un <i>path</i> es una secuencia de nodos \((n_0, n_1, \ldots n_k)\)</li>
<li>Una <b>meta</b> es una función booleana de los nodos, si <code>goal(n_k)</code> es
verdadero, \(n_k\) es el <b>nodo meta</b></li>
<li>El <b>costo</b> es un número <i>no negativo</i> asociado con los arcos. El costo
de los arcos induce el costo de los <i>paths</i>. La  <b>solución óptima</b>  es
aquella que minimiza el costo.</li>

</ul></form>

</section>
<section>

<form><ul>
<li>Un <b>ciclo</b> es un <i>path</i>  no vacío cuyo nodo inicial es igual al nodo
final.</li>
<li>Una <b>DAG</b> es un grafo dirigido sin ciclos.</li>
<li>Un <span class="underline">árbol</span> es un <b>DAG</b> con un nodo que no tiene arcos entrantes (<i>root</i>) y todos
los demás nodos tienen <span class="underline">exactamente</span> un arco entrante (<i>leaf</i>).</li>

</ul></form>

</section>
<section>

<form><ul>
<li>El <b>grado</b> de un nodo \(n\), \(deg(n)\) es el número de arcos que salen y entran de
él, es decir, los arcos incidentes al nodo.</li>
<li>En un <span class="underline">multigrafo</span> los <i>loops</i> son contados dos veces.</li>
<li>En un grafo dirigido, este concepto se extienda a <i>indegree</i> y
<i>outdegree</i> para los arcos que entran y salen del nodo respectivamente.</li>

</ul></form>

</section>
<section>

<form><ul>
<li>Un <span class="underline">multigrafo</span> es un grafo que puede tener múltiples arcos,
i.e. arcos que tienen el mismo nodo terminal en común.</li>

<li>Un <span class="underline">hipergrafo</span> es un grafo en el cual un arco puede conectar
cualquier número de nodos, en lugar de solamente dos.</li>

</ul></form>

</section>
</section>
<section>
<section id="slide-orgc8bd1e9">
<h2 id="orgc8bd1e9">Representación</h2>
<div class="outline-text-2" id="text-orgc8bd1e9">
</div>
</section>
<section id="slide-orga8dc83b">
<h3 id="orga8dc83b">Matriz de Adyacencia</h3>
<form><ul>
<li>Una  matriz \(A\) 

<form><ul>
<li>\(a_{ij} = 1\) si hay una arista de \(i \to j\)</li>
<li>\(a_{ij} = 0\) de otra manera</li>

</ul></form></li>

</ul></form>

</section>
<section id="slide-org2343329">
<h3 id="org2343329">Lista de Adyacencia</h3>
<form><ul>
<li>Cada nodo tiene una lista de los nodos que están conectados mediante
aristas salientes (i.e. de \(i \to j\))</li>

</ul></form>


</section>
<section id="slide-orgcf593db">
<h3 id="orgcf593db">Ejemplo</h3>

<div class="figure">
<p><img src="../images/graph-1.png" alt="graph-1.png" width="400px" height="400px">
</p>
</div>

<p>
Se puede representar como lista de adyacencia como sigue:
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >graph = {}
graph["A"] = {"B", "C"}
graph["B"] = {"D", "E", "C"}
graph["C"] = {"E"}
graph["D"] = {"E", "F"}
graph["E"] = {"F"}
graph["F"] = set()
graph["G"] = set()
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-org1027e93">
<h2 id="org1027e93">Ejemplos de Redes</h2>
<table>
<caption class="t-above"><span class="table-number">Table 1:</span> Algunos ejemplos de mapeos de sistemas reales a una red. Tomado de <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a></caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Nodos</th>
<th scope="col" class="org-left">Arcos</th>
<th scope="col" class="org-left">Flujo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Cruceros</td>
<td class="org-left">Caminos</td>
<td class="org-left">Vehículos</td>
</tr>

<tr>
<td class="org-left">Aeropuertos</td>
<td class="org-left">Líneas aéreas</td>
<td class="org-left">Aviones</td>
</tr>

<tr>
<td class="org-left">Puntos de conmutación</td>
<td class="org-left">Cables, canales</td>
<td class="org-left">Mensajes</td>
</tr>

<tr>
<td class="org-left">Estaciones de bombeo</td>
<td class="org-left">Tuberías</td>
<td class="org-left">Fluidos</td>
</tr>

<tr>
<td class="org-left">Centros de trabajo</td>
<td class="org-left">Rutas de manejo de materiales</td>
<td class="org-left">Trabajos</td>
</tr>
</tbody>
</table>

</section>
</section>
<section>
<section id="slide-org0cc1439">
<h2 id="org0cc1439">Orden Topológico</h2>
<p>
<i>Entrada</i>: <b><b>DAG</b></b> \(G = (N, A)\)
</p>

<p>
<i>Salida</i>: Una lista ordenada de nodos tal que para cada arista \(i \to j\), \(i\) aparezca primero que \(j\).
</p>

<p>
Obviamente puede haber varias respuestas
</p>

<p>
Uno de los algoritmos más fáciles de implementar (y bastante rápido \(\mathcal{O}(n + m)\)) es el <span class="underline">algoritmo de Kahn</span>.
</p>

</section>
<section id="slide-org63f885a">
<h3 id="org63f885a">Algoritmo de Kahn</h3>
<p>
La idea básica es remover repetidamente los nodos \(v\) que tienen \(indeg(v) = 0\).
</p>

<form><ol>
<li>Determinar el <i>in-degree</i> de cada nodo</li>
<li>Colocar los nodos con \(indeg(v) = 0\) en una cola</li>
<li>Mientras la cola no esté vacía
<form><ul>
<li>u \(\leftarrow\) pop()</li>
<li>Remover \(u\) del grafo</li>
<li>Verificar si no hay un nuevo nodo con \(indeg(v) = 0\) entre los vecinos de \(u\)</li>
<li>Si existe, agregarlo a la cola</li>

</ul></form></li>
<li>Mantenemos una lista con los nodos en el orden en que son removidos</li>
<li>Si la cola está vacía
<form><ul>
<li>Regresar la lista</li>
<li>Si está vacía <span class="underline">hay ciclos</span></li>

</ul></form></li>

</ol></form>


</section>
<section id="slide-orge1d9557">
<h3 id="orge1d9557">Ejemplo</h3>
<p>
(<i>Tomado del libro</i> <b>A Gentle Introduction to Optimization</b>) 
</p>

<p>
Quieres construir una casa y has dividio el proceso en un conjunto de tareas:
</p>

<form><ul>
<li>\(B\) :  Excavación y construcción de los fundamentos</li>
<li>\(F\) :  Establecer el marco de madera</li>
<li>\(E\) :  Cableado eléctrico</li>
<li>\(P\) :  Plomería interna</li>
<li>\(D\) :  Paredes y pisos</li>
<li>\(L\) :  <i>Landscaping</i></li>

</ul></form>

<p>
Las cuales tienen los siguientes estimados (en semanas):
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Tarea</th>
<th scope="col" class="org-right">B</th>
<th scope="col" class="org-right">F</th>
<th scope="col" class="org-right">E</th>
<th scope="col" class="org-right">P</th>
<th scope="col" class="org-right">D</th>
<th scope="col" class="org-right">L</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Duración</td>
<td class="org-right">3</td>
<td class="org-right">2</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
</tr>
</tbody>
</table>

</section>
<section>

<p>
Algunas tareas sólo pueden empezar cuando las otras han concluido:
</p>

<form><ul>
<li>\(F\) puede empezar sólo si \(B\) ya se completó</li>
<li>\(L\) puede empezar sólo si \(B\) ya se completó</li>
<li>\(E\) puede empezar sólo si \(F\) ya se completó</li>
<li>\(P\) puede empezar sólo si \(F\) ya se completó</li>
<li>\(D\) puede empezar sólo si \(E\) ya se completó</li>
<li>\(D\) puede empezar sólo si \(P\) ya se completó</li>

</ul></form>

<p>
La meta es determinar los tiempos de cada tarea tal que el proyecto
completo sea terminado lo antes posible
</p>

</section>
<section>


<div class="figure">
<p><img src="../images/landscaping_example.png" alt="landscaping_example.png" width="300px" height="350px">
</p>
<p><span class="figure-number">Figure 2: </span>Grafo de dependencia de actividades del ejemplo de <i>landscaping</i></p>
</div>


</section>
<section>

<p>
En <code>python</code>
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >tasks = {}
tasks['B'] = {'F', 'L'}
tasks['F'] = {'E', 'P'}
tasks['E'] = {'D'}
tasks['P'] = {'D'}
tasks['L'] = set()
tasks['D'] = set()
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >topological_order(tasks)
</code></pre>
</div>


</section>
</section>
<section>
<section id="slide-org8e0c6ff">
<h2 id="org8e0c6ff">Rutas más cortas</h2>
<p>
El algoritmo <b>BFS</b> nos da la ruta más corta entre dos nodos, si todos
los vértices tienen un costo \(1\). 
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >def shortest_path(graph, source, target):
    """
    Devuelve el path más corto, asumiendo que el costo es 1 en *todos* los arcos
    """
    goal = lambda nodo: nodo == target
    try:
        return next(BFS(graph, source, goal))
    except StopIteration:
        return None
</code></pre>
</div>

<p>
Si tenemos costos en los arcos, <b>BFS</b>  no nos da la
ruta más corta. Para eso, debemos de utilizar el <i>algoritmo de Dijkstra</i> 
</p>

</section>
<section>

<p>
El problema  es planteado como un problema de optimización de la manera siguiente:
</p>

<p>
Sea un grafo \(G = (N,A)\) con un <b>costo</b> en
cada arco \((i,j) \in  A\), \(c_{ij}\).
\(G\) tiene un nodo especial, designado por \(s\)
(<b>source</b>). 
 Sea \(A(i)\) la lista de arcos
adyacentes al nodo \(i\) y sea \(C = max\{c_{ij}: (i,j) \in  A\}\). 
</p>

<p>
Definimos
la <b>longitud de un camino dirigido</b> como la suma de costos de los arcos
en el camino (<b>path</b>). El problema  de la distancia mínima es encontrar
para cada nodo $ i &isin; N &ne; s$ la longitud de camino dirgido desde \(s\) a
\(i\).  
</p>

</section>
<section>

<p>
También se puede plantear como el problema de mandar una unidad de
flujo tan baratamente como sea posible del nodo \(s\) a cada uno de los
nodos en \(N - \{s\}\): 
</p>

<div>
\begin{equation*}
\begin{aligned}
& \text{min}  
& & \sum_{(i,j) \in A} c_{ij}x_{ij}  \\
& \text{s.t.}   \\
& & & \sum_{j:(i,j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = \Bigg\{
\begin{array}{ll} 
n -1 & \text{para} \ &  i = s \\
-1 & \text{para todo} & i \in N - s
\end{array} 
\\ 
& & & x_{ij} \geq 0 \ \ \  \text{para todo} \  (i,j) \in A
\end{aligned}
\end{equation*}

</div>

</section>
<section id="slide-org07c05b7">
<h4 id="org07c05b7">Suposiciones</h4>
<p>
Las suposiciones que hace este problema son:
</p>

<form><ol>
<li>Todas las longitudes de arco son enteras</li>
<li>La red contiene un camino dirigido del nodo \(s\) a cualquier otro
nodo de la red  (Si esto no se cumple siempre podemos agregar arcos
"<b>ficticios</b>" con un costo muy grande)</li>
<li>El grafo no contiene un ciclo negativo</li>

</ol></form>

<p>
Si se violan las suposiciones 1 y 3, se debe de utilizar el algoritmo
de Bellman-Ford.
</p>

</section>
<section id="slide-orge4eca46">
<h3 id="orge4eca46">Algoritmo de Dijkstra</h3>
<p>
El algoritmo de Dijkstra no es complicado en sí:
</p>

<p>
<i>Entrada</i>: Un <b>DAG</b> \(G(N,A)\), un nodo \(s \in N\), un nodo \(t \in N\), una lista \(C_A\)
con los costos de todos los arcos en A.
</p>

<p>
<i>Salida</i>: Lista de vértices \(v\) con el costo más pequeño de \(s\) a \(v\)
</p>

<form><ol>
<li>Encuentra el nodo más <b>barato</b>, i.e. el nodo al que puedes
llegar con el menor costo, a esto le llamamos <i>dijkstra score</i>.</li>
<li>Actualiza los <i>dijkstra scores</i> de los vecinos a ese nodo.</li>
<li>Repite hasta que se haya hecho esto para todos los nodos del grafo.</li>
<li>Calcula el <b>path</b> final.</li>

</ol></form>

<p>
Es importante mencionar, que al igual que el algoritmo de ordenamiento
topológico, el algoritmo de Dijkstra sólo funciona con DAGs. 
</p>

</section>
<section>

<p>
Escrito como <b>pseudocódigo</b> es lo siguiente:
</p>

<pre class="example">
       algoritmo dijkstra ( G, costs, source, target )
           S = {} 
           S' = {N}
           d[i] = infinity para todos los nodos i en N
           d[source] &lt;- 0
           pred[s] &lt;- 0
           while |S| &lt; |N|:
               i &lt;- arg{d[i] = min{d[j] j in S'}} # node selection
               S &lt;- S + i
               S' &lt;- S' - i
               for each (i,j) en A(i) 
                   if d[j] &gt; d[i] + costs[i,j]  then # dijkstra_score
                       d[j] &lt;- d[i] + costs[i,j] # distance update
                       pred[j] &lt;- i
</pre>

<div class="org-src-container">

<pre><code class=" jupyter-python" >def pretty_dijkstra(network, source, target):
    solucion = dijkstra(network, source, target)
    predecesores = solucion['predecesores']
    dijkstra_scores = solucion['dijkstra_scores']
    
    path = deque()
    if source in predecesores and target in predecesores:
        path.extend(target)
        nodo = target
        while nodo is not source:
            nodo = predecesores[nodo]
            path.extendleft(nodo)
    return {'path': list(path), 'costo': dijkstra_scores[target]}
</code></pre>
</div>

</section>
<section id="slide-org0048f2e">
<h3 id="org0048f2e">Ejemplo</h3>

<div class="figure">
<p><img src="../images/shortest_path_example.png" alt="shortest_path_example.png" width="500px" height="250px">
</p>
<p><span class="figure-number">Figure 3: </span>Grafo para el ejemplo de la ruta más corta</p>
</div>

</section>
<section id="slide-orgaf688bc">
<h4 id="orgaf688bc">Implementación en <code>Python</code></h4>
<p>
Nota que nuestra <span class="underline">red</span> ahora tiene más riqueza que los grafos
anteriores. Ahora tenemos información en el arco. Esta información,
nos obliga a cambiar la estructura de datos que estábamos usando hasta ahora:
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >example_1 = {}
example_1["s"] = {}
example_1["s"]["A"] = 6
example_1["s"]["B"] = 2
example_1["A"] = {}
example_1["A"]["t"] = 1
example_1["B"] = {}
example_1["B"]["A"] = 3
example_1["B"]["t"] = 5
example_1["t"] = {}
</code></pre>
</div>

<p>
Tenemos un diccionario dentro de un diccionario.
</p>

<p>
<i>Ejercicio</i>: ¿Cuál es el costo usando <b>BFS</b>?
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >pretty_dijkstra(example_1, 's', 't')
</code></pre>
</div>

<pre class="example">
: {'path': ['s', 'B', 'A', 't'], 'costo': 6}
</pre>


</section>
<section id="slide-org8506948">
<h3 id="org8506948">Ejemplo</h3>

<div class="figure">
<p><img src="../images/shortest_path_example_2.png" alt="shortest_path_example_2.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 4: </span>Grafo para el segundo ejemplo de la ruta más corta</p>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >example_2 = {}
example_2["A"] = {}
example_2["A"]["B"] = 6
example_2["A"]["C"] = 4
example_2["B"] = {}
example_2["B"]["C"] = 2
example_2["B"]["D"] = 2
example_2["C"] = {}
example_2["C"]["D"] = 1
example_2["C"]["E"] = 2
example_2["D"] = {}
example_2["D"]["F"] = 7
example_2["E"] = {}
example_2["E"]["D"] = 1
example_2["E"]["F"] = 3
example_2["F"] = {}
</code></pre>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >pretty_dijkstra(example_2, 'A', 'F')
</code></pre>
</div>

<pre class="example">
: {'path': ['A', 'C', 'E', 'F'], 'costo': 9}
</pre>

</section>
<section id="slide-orgc7f96e9">
<h3 id="orgc7f96e9">Ejemplo</h3>

<div class="figure">
<p><img src="file:///home/nanounanue/pCloudDrive/org/clases/operations-research/images/shortest_path_example_3.png" alt="shortest_path_example_3.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 5: </span>Grafo para el tercer ejemplo de la ruta más corta</p>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >example_3 = {}
example_3["A"] = {}
example_3["A"]["B"] = 5
example_3["A"]["C"] = 3
example_3["A"]["D"] = 8
example_3["B"] = {}
example_3["B"]["C"] = 3
example_3["B"]["D"] = 2
example_3["C"] = {}
example_3["C"]["E"] = 4
example_3["C"]["F"] = 8
example_3["D"] = {}
example_3["D"]["C"] = 4
example_3["D"]["F"] = 2
example_3["E"] = {}
example_3["E"]["D"] = 4
example_3["E"]["F"] = 3
example_3["F"] = {}
</code></pre>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >pretty_dijkstra(example_3, 'A', 'F')
</code></pre>
</div>

<pre class="example">
: {'path': ['A', 'B', 'D', 'F'], 'costo': 9}
</pre>


</section>
<section id="slide-orgd4e1ea3">
<h3 id="orgd4e1ea3">Ejemplo</h3>
<p>
<i>¿Cuál es la programación más efectiva en costo para remplazar equipo en un periodo de tiempo?</i>
(Tomado de:  <b>Operations Research A practical Introduction</b>)
</p>

<p>
Supongamos que tienes circuitos para conversión de analógico a digital
en una computadora de navegación que deben de ser remplazados en
intervalos en un periodo de 6 meses. Idealmente, el reemplazo debe
ocurrir <b>antes</b> de que ocurra una falla, pero, reemplazos frecuentes
incurren en costos de capital y costos de labor para la instalación,
por otro lado, si no se hacen, es decir, hay pocos reemplazos, quizá
esta decisión lleve a costos de mantenimiento y a tiempos muy grandes
sin operación. 
</p>

<p>
Se han recolectado costos de la compra, instalación, mantenimiento,
costos de downtime que han sido resumidos en la siguiente tabla:  
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">

<col  class="org-right">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">PCB Reemplazado</th>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">Feb</th>
<th scope="col" class="org-right">Mar</th>
<th scope="col" class="org-right">Abr</th>
<th scope="col" class="org-right">May</th>
<th scope="col" class="org-right">Jun</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><b>PCB instalado</b></td>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Ene</td>
<td class="org-right">5.00</td>
<td class="org-right">6.75</td>
<td class="org-right">8.25</td>
<td class="org-right">12.50</td>
<td class="org-right">16.80</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Feb</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">5.25</td>
<td class="org-right">6.25</td>
<td class="org-right">9.50</td>
<td class="org-right">11.50</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Mar</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">5.25</td>
<td class="org-right">7.25</td>
<td class="org-right">9.00</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">Abr</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">5.50</td>
<td class="org-right">8.20</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">May</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">5.80</td>
</tr>
</tbody>
</table>

</section>
<section>

<p>
<i>Ejercicio</i>  
</p>
<form><ul>
<li>Plantea el problema como un grafo: Cada nodo representa un  mes y
los arcos están etiquetados con los costos de la tabla</li>
<li>¿Cuál es el camino más corto para cada <b>A/D</b> instalado en los meses de
Enero y Febrero?</li>

</ul></form>

</section>
</section>
<section>
<section id="slide-orgb720d39">
<h2 id="orgb720d39">Árboles de expansión mínima</h2>
<form><ul>
<li>Este problema es muy parecido al de <i>ruta más corta</i>.</li>
<li>Queremos seleccionar <i>arcos</i> que minimicen el costo entre <span class="underline">cada</span> par de
nodos.</li>
<li>La versión que veremos se conoce como <span class="underline">algoritmo de Prim</span>. Es un
algoritmo <i>greedy</i>.</li>

</ul></form>


</section>
<section id="slide-org024fb2a">
<h3 id="org024fb2a">Pseudo algoritmo</h3>
<form><ol>
<li>Sea \(N\) el conjunto de nodos de la red</li>
<li>\(S={\emptyset}\) y \(S'={N}\) son conjuntos con los nodos conectados y no,
respectivamente</li>
<li>Seleccionar cualquier nodo de \(S'\) y páselo a \(S\)</li>
<li>Mientras \(S'\) no esté vacío
<form><ol>
<li>Seleccionar el nodo \(j\) de \(S'\) que produzca el arco más corto a
un nodo de \(S\)</li>
<li>Pasarlo a \(S\)</li>
<li>Repetir</li>

</ol></form></li>

</ol></form>


</section>
<section id="slide-orgcb8e84c">
<h3 id="orgcb8e84c">Ejemplo</h3>

<div class="figure">
<p><img src="../images/arbol_expansion_minima_1.png" alt="arbol_expansion_minima_1.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 6: </span>Grafo para el ejemplo del árbol de expansión mínima. Tomado de <a class="org-ref-reference" href="#slide-bibliography">[tahaInvestigacionOperaciones10a2017]</a></p>
</div>

</section>
<section id="slide-org5bbe6d0">
<h3 id="org5bbe6d0">Implementación en <code>python</code></h3>
<div class="org-src-container">

<pre><code class=" jupyter-python" >mst = {}
mst['1'] = {}
mst['1']['2'] = 1
mst['1']['4'] = 7
mst['1']['3'] = 5
mst['1']['5'] = 9

mst['2'] = {}
mst['2']['1'] = 1
mst['2']['3'] = 7
mst['2']['4'] = 4
mst['2']['5'] = 3

mst['3'] = {}
mst['3']['1'] = 5
mst['3']['2'] = 7
mst['3']['6'] = 10
mst['3']['4'] = 5

mst['4'] = {}
mst['4']['1'] = 7
mst['4']['2'] = 4
mst['4']['3'] = 5
mst['4']['5'] = 8
mst['4']['6'] = 3

mst['5'] = {}
mst['5']['1'] = 9
mst['5']['4'] = 8
mst['5']['2'] = 3

mst['6'] = {}
mst['6']['4'] = 3
mst['6']['3'] = 10
</code></pre>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >arbol_expansion_minima(mst)
</code></pre>
</div>


<div class="figure">
<p><img src="../images/minimum_spanning_tree_sol_1.png" alt="minimum_spanning_tree_sol_1.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 7: </span>Grafo solución para el ejemplo del árbol de expansión mínima. En rojo se muestra una arco alterno. Tomado de <a class="org-ref-reference" href="#slide-bibliography">[tahaInvestigacionOperaciones10a2017]</a></p>
</div>



</section>
</section>
<section>
<section id="slide-orgeec6dd6">
<h2 id="orgeec6dd6">Ejemplo</h2>
<form><ul>
<li>El parque Seervada <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a> es
utilizado para <i>camping</i> y paseos.  Posee el siguiente sistema de
caminos:</li>

</ul></form>


<div class="figure">
<p><img src="../images/seervada_park_1.png" alt="seervada_park_1.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 8: </span>Estructura de caminos del Parque Seervada. Ejemplo tomado de <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a></p>
</div>

<p>
Siendo <b>O</b> la entrada al parque y <b>T</b> un mirador. Muchos visitantes van al
parque justo a esta atracción.
</p>

</section>
<section id="slide-orga34446a">
<h3 id="orga34446a">Implementación en <code>python</code></h3>
<div class="org-src-container">

<pre><code class=" jupyter-python" >seervada = {}
seervada['O'] = {}
seervada['O']['A'] = 2
seervada['O']['B'] = 5
seervada['O']['C'] = 4

seervada['A'] = {}
seervada['A']['O'] = 2
seervada['A']['B'] = 2
seervada['A']['D'] = 7

seervada['B'] = {}
seervada['B']['O'] = 5
seervada['B']['A'] = 2
seervada['B']['C'] = 1
seervada['B']['D'] = 4
seervada['B']['E'] = 3

seervada['C'] = {}
seervada['C']['O'] = 4
seervada['C']['B'] = 1
seervada['C']['D'] = 4

seervada['D'] = {}
seervada['D']['A'] = 7
seervada['D']['B'] = 4
seervada['D']['E'] = 1
seervada['D']['T'] = 5

seervada['E'] = {}
seervada['E']['B'] = 3
seervada['E']['C'] = 4
seervada['E']['D'] = 1
seervada['E']['T'] = 7

seervada['T'] = {}
seervada['T']['D'] = 5
seervada['T']['E'] = 7
</code></pre>
</div>



</section>
<section id="slide-orgfaaadeb">
<h3 id="orgfaaadeb">Problemas del Parque Seerveda</h3>
<p>
El parque enfrenta tres problemas principalmente
</p>

<form><ol>
<li>¿Cuál es la ruta más corta, desde la entrada del parque a la
estación <b>T</b>?</li>

</ol></form>

<div class="org-src-container">

<pre><code class=" jupyter-python" >shortest_path(seervada, 'O', 'T')
</code></pre>
</div>


<div class="figure">
<p><img src="../images/seervada_park_sol_1.png" alt="seervada_park_sol_1.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 9: </span>Ruta más corta de la entrada del parque al mirador T del Parque Seervada. Ejemplo tomado de <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a></p>
</div>

</section>
<section>

<form><ol>
<li>Deben de instalarse líneas telefónicas subterráneas, ¿por dónde
deben de tenderse las líneas para lograr la comunicación entre
cualquier par de estaciones con el <i>mínimo</i> número de km de cableado?</li>

</ol></form>

<div class="org-src-container">

<pre><code class=" jupyter-python" >arbol_expansion_minima(seervada)
</code></pre>
</div>


<div class="figure">
<p><img src="../images/seervada_park_sol_2.png" alt="seervada_park_sol_2.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 10: </span>Árbol de expansión mínima del parque al mirador T del Parque Seervada. Ejemplo tomado de <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a></p>
</div>

</section>
<section>

<form><ol>
<li>En temporada alta, hay más personas que quieren ir a <b>T</b> de las que
se les puede dar servicio. Para no perturbar/dañar el ecosistema
del parque se han establecido límites al número de viajes que
pueden hacerse en los tramos. ¿Cómo planear las rutas de los
distintos viajes de manera que se <i>maximice</i> el número total de
viajes que se pueden hacer al día?</li>

</ol></form>



<div class="figure">
<p><img src="../images/seervada_park_2.png" alt="seervada_park_2.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 11: </span>Red de caminos del Parque Seervada. Los arcos muestran su capacidad máxima, no la distancia. Tomado de <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a></p>
</div>



</section>
</section>
<section>
<section id="slide-orgfaeae77">
<h2 id="orgfaeae77">Maximum Flow</h2>
<p>
El problema de flujo máximo (<b>maximum flow problem</b>) está muy
relacionado con el de <b>shortest path</b>, pero en lugar de hacer uso de los
<span class="underline">costos</span> como este, se encarga de las <span class="underline">capacidades</span>.
</p>

</section>
<section>

<p>
El problema de flujo máximo se puede plantear como sigue: Sea \(G(N,A)\) un grafo
en el cual los nodos \(1\) y \(n\), \(\in N\) se denominan <b>source</b> y <b>target</b> (también los
llamaremos \(s\) y \(t\), <i>origen</i> y <i>destino</i>, <i>fuente</i> y <i>sumidero</i>, etc).  A los nodos restantes se les conoce como
<i>nodos de transbordo</i>. Las variables de decisión \(x_{ij}\)  denotan la cantidad de
flujo a lo largo del arco \((i,j) \in A\). La capacidad del arco \((i,j) \in A\) se denota
por \(u_{ij}\).
</p>

<div>
\begin{equation*}
\begin{aligned}
& \text{max}  
& & z = f  \\
& \text{s.t.}   \\
& & & \sum_{i = 2}^n x_{1i} = f \\
& & & \sum_{i = 1}^{n -1} x_{in} = f \\
& & & \sum_{i = 1}^n x_{ij} - \sum_{k = 1}^n x_{jk} & \ \text{para} \ j  = 2,3,\ldots,n - 1 \\
& & & x_{ij} \leq u_{ij}  & \ \text{para todo} i, j = 1,  \ldots, n \\
& & & x_{ij} \geq 0
\end{aligned}
\end{equation*}

</div>

</section>
<section>

<p>
La función a optimizar, \(f\), representa el
flujo total a lo largo de la red. La primera restricción asegura que
el flujo \(f\) salga del <b>source</b> y la segunda que el flujo \(f\) llegue a
<b>target</b>. La tercera restricción se conoce como <b>ecuaciones de
conservación de flujo</b> y las últimas dos aseguran que no se violen las
limitantes físicas del arco. En particular las <b>ecuaciones de
conservación de flujo</b> hacen redundante la segunda restricción. 
</p>

</section>
<section id="slide-org40f5bda">
<h4 id="org40f5bda">Restricciones</h4>
<p>
Las restricciones se pueden resumir en 
</p>

<form><ol>
<li>La cantidad de flujo que <b>entra</b> a cualquier nodo, excepto \(s\)
(origen) y \(t\) (destino) es igual a la cantidad de flujo que <b>sale</b>
de él;</li>
<li>Un máximo de \(u_{ij}\) puede moverse a lo largo de cualquier arco en
\(A\), en la dirección indicada por el arco.</li>

</ol></form>

</section>
<section id="slide-org85d9e51">
<h4 id="org85d9e51">Suposiciones</h4>
<p>
Las suposiciones son:
</p>

<form><ol>
<li>La red es dirigida</li>
<li>Todas las capacidades son <b>enteros</b> no negativos i.e. \(u_{ij} \geq 0 \in  \mathbf{Z}\)</li>
<li>En \(s\) todos los arcos señalan hacia afuera, en \(t\) todos los arcos
señalan hacia adentro.</li>
<li>La red no contiene un camino dirigido de \(s\) a \(t\) compuesto únicamente por arcos de capacidad infinita.</li>
<li>Siempre que haya un arco \((i,j) \in A\), \((j,i)\) también pertenece a \(A\).
<form><ul>
<li>No es restrictiva ya que los arcos que no aparecen, tienen capacidad cero.</li>

</ul></form></li>
<li>La red no contiene arcos paralelos.
<form><ul>
<li>Esta última suposición es para que la notación sea más sencilla.</li>

</ul></form></li>

</ol></form>

</section>
<section id="slide-org0d2f045">
<h3 id="org0d2f045">Algoritmo Ford Fulkerson</h3>
<p>
El algoritmo para resolver el problema de flujo máximo, es el algoritmo de <span class="underline">Ford-Fulkerson</span>, en <b>pseudocódigo</b> es:
</p>

<p>
La idea intuitiva del algoritmo de Ford-Fulkerson consiste en
encontrar uno a uno todos los caminos de aumento de una red y aumentar
el flujo sobre estos caminos hasta que ya no se pueda enviar más flujo
de la fuente al sumidero.
</p>

<pre class="example">
algoritmo ford_fulkerson(grafo, s, t)
    flujos[i,j] &lt;- 0, para todo (i,j) en A
    invocar función encontrar_flujo
    si existen caminos por aumentar
        encontrar aumentar_camino
        incrementar el flujo
        invocar incrementar_flujo
</pre>

<p>
Hay varias maneras de explicar el algoritmo que resuelve este
problema. En estas notas usaremos el método de la <b>red residual</b>,
siguiendo a <a class="org-ref-reference" href="#slide-bibliography">[ahujaNetworkFlowsTheory1993]</a>, aunque también se
puede leer una explicación similar en <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a>.
</p>

</section>
<section id="slide-org957e580">
<h3 id="org957e580">Red residual</h3>
<p>
Dado un flujo \(x\), la capacidad residual \(r_{ij}\) de \((i,j) \in A\) es el
<span class="underline">máximo flujo adicional</span> que puede ser mandado de \(i\) a \(j\) usando los
arcos \((i,j)\) y \((j.i)\). 
</p>

<p>
La capacidad residual \(r_{ij}\) tiene dos componentes (1) \(u_{ij} - x_{ij}\), la
capacidad disponible \(u_{ij}\)  de \((i,j)\) y (2) El flujo actual \(x_{ji}\) en el arco
\((j,i)\) el cual podemos cancelar al incrementar el flujo de \(i\) a
\(j\). 
</p>

<p>
\[
r_{ij} = u_{ij} - x_{ij} +  x_{ji}
\]
</p>

</section>
<section>

<p>
Diremos que \(G(x)\) es la <b>red residual</b> respecto al flujo \(x\), como
aquella red que contiene los arcos con \(r_{ij} \geq 0\). 
</p>

</section>
<section>


<div class="figure">
<p><img src="../images/red_original_max_flow.png" alt="red_original_max_flow.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 12: </span>Red original. Antes de aplicar el algoritmo de red residual.</p>
</div>

</section>
<section>

<p>
Esta red es más compleja que las anteriores, ya que tiene más de un
atributo en los arcos, <code>capacidad</code> y <code>flujo</code>.
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >G = {}
G['A'] = {}
G['A']['B'] = { 'capacidad':2, 'flujo':2 }
G['A']['C'] = { 'capacidad':4, 'flujo':3 }
G['B'] = {}
G['B']['C'] = { 'capacidad':3, 'flujo':2 }
G['B']['D'] = { 'capacidad':1, 'flujo':0 }
G['C'] = {}
G['C']['D'] = {'capacidad':5, 'flujo':5}
G['D'] = {}
</code></pre>
</div>


</section>
<section>

<p>
La red residual se ve así:
</p>


<div class="figure">
<p><a href="file:///home/nanounanue/pCloudDrive/org/clases/operations-research/images/red_residual_max_flow.png" width="500px" height="350px"><img src="../images/red_residual_max_flow.png" alt="red_residual_max_flow.png" width="500px" height="350px"></a>
</p>
<p><span class="figure-number">Figure 13: </span>Red residual que se obtiene después de aplicar el algoritmo de red residual.</p>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >residual_network(G)
</code></pre>
</div>

<pre class="example">
: {'A': {'C': {'capacidad': 1}},
:  'B': {'A': {'capacidad': 2}, 'C': {'capacidad': 1}, 'D': {'capacidad': 1}},
:  'C': {'A': {'capacidad': 3}, 'B': {'capacidad': 2}},
:  'D': {'C': {'capacidad': 5}}}
</pre>

</section>
<section id="slide-org793c431">
<h3 id="org793c431">Forward y Backward edges</h3>
<p>
Sea \(x\) un flujo en la red. Si el flujo, \(x_{ij}\) que cruza el arco
\((i,j)\) es menor que \(u_{ij}\), decimos que la red residual tiene un
<b>forward edge</b> entre \(i\) y \(j\)  con una capacidad igual a la \(u_{ij} -
x_{ij}\), llamada capacidad residual, \(r_{ij}\).  
</p>

<p>
Si \(x_{ij}\) es positivo hay un <b>backward edge</b> \((j,i)\) con una capacidad
igual a \(x_{ij}\). 
</p>

<p>
Nota que en la red aumentada los arcos con flujo igual a cero, son
removidos. 
</p>

</section>
<section id="slide-orgaf15654">
<h3 id="orgaf15654">Augmenting path</h3>
<p>
Un camino aumentado (<b>augmenting path</b>) es simplemente un camino que va
de \(s\) a \(t\) en la red residual \(G(x)\).  El mínimo de las capacidades
residuales se llama <span class="underline">capacidad residual de la trayectoria de aumento</span>,
porque es la cantidad de flujo que es factible agregar en toda la
trayectoria.
</p>

<p>
Nota que existe un <span class="underline">flujo positivo</span> entre los nodos fuente y sumidero a
lo largo del <i>augmenting path</i> en la red original \(G\). Es decir, en \(G\)
hay un camino (no necesariamente dirigido) de la fuente al destino con
\(x_{ij} < u_{ij}\) en cada <i>forward arc</i> \((i,j)\) y \(x_{ij} >0\) en cada <i>backward arc</i> \((i,j)\).
</p>

</section>
<section id="slide-org7a5ada3">
<h3 id="org7a5ada3">Algoritmo de Ford-Fulkerson (de nuevo)</h3>
<p>
Empieza sin flujo en la red, luego incrementa el flujo de la red
mientras haya un <b>augmenting path</b> de \(s\) a \(t\) que no contenga <b>forward
edges</b> llenos o <b>backward edges</b> vacíos, i.e. mientras haya un camino en
la red residual. 
</p>

<pre class="example">
algoritmo ford_fulkerson(G, s, t)
    f[i,j] &lt;- 0 , para todo (i,j) en A
    G_x &lt;- G
    while augmenting_path in G_x
        p &lt;- find directed path en G_x de s a t
        si p
            d_f = min { u_ij, (i,j) en p }
            for (i,j) en p
                if forward(i,j)
                    f[i,j] = f[i,j] + d_f
                if backward(i,j)
                    f[i,j] = f[i,j] - d_f
             actualizar G_x
    return f, suma de flujos que llegan a t
</pre>

<p>
Lo único que queda por especificar es como encontrar un camino
dirigido en \(G(x)\) de \(s\) a \(t\). Una opción es utilizar los algoritmos
de búsqueda, en particular, podemos usar el algoritmo <b>BFS</b>. Si lo
hacemos así, el algoritmo se llama <span class="underline">algoritmo de Edmons-Karp</span>.
</p>

</section>
<section>

<p>
<i>Ejercicio</i>
</p>

<p>
Implementa el algoritmo Ford-Fulkerson, con la siguiente firma:
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >def ford_fulkerson(graph, s, t, augmenting_path=shortest_path):
    ...
    return {'flow':{}, 'max_flow': max_flow}
</code></pre>
</div>

<p>
donde el valor del parámetro <code>augmenting_path</code> es el nombre de una
función, por <b>default</b> será <b>BFS</b>.
</p>


</section>
<section id="slide-org247e2c9">
<h3 id="org247e2c9">Ejemplo: Paso a paso</h3>
<p>
Volvamos a la red del primer ejemplo, pero haciendo todos los flujos
\(x_{ij} = 0\)
</p>


<div class="figure">
<p><img src="../images/red_original_max_flow_a.png" alt="red_original_max_flow_a.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 14: </span>Red original. Nota que todos los flujos son cero inicialmente.</p>
</div>

</section>
<section id="slide-orga962cc2">
<h4 id="orga962cc2">Primera iteración</h4>
<p>
La red residual, se obtiene haciendo, en el arco \((i,j)\), que su
capacidad sea  \(u_{ij} - x_{ij}\) y en el arco \((j,i)\), \(x_{ij}\). 
</p>


<div class="figure">
<p><img src="../images/red_residual_max_flow_a.png" alt="red_residual_max_flow_a.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 15: </span>Red residual en la primera iteración.</p>
</div>

</section>
<section>

<p>
Existen tres <i>augmented paths</i>: \(A \to B \to D\), \(A \to B \to C \to D\) y \(A \to C \to D\).
</p>

<p>
Elijamos \(A \to B \to C \to D\) (marcado en azul)
</p>


<div class="figure">
<p><img src="../images/red_residual_augmented_path_max_flow_a.png" alt="red_residual_augmented_path_max_flow_a.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 16: </span>Seleccionamos uno de los tres augmented paths de la red residual (mostrado en azul). La capacidad residual es 2. Todos los arcos son <i>forward arcs</i>.</p>
</div>

<p>
La <i>capacidad residual del augmented path</i> es <b>2</b>.
</p>

</section>
<section>

<p>
Actualizamos la red original, aumentamos en <b>2</b> el flujo del camino \(A\to B \to C \to
D\). Todos los arcos de este camino son <i>forward arcs</i>.
</p>


<div class="figure">
<p><img src="../images/red_original_updated_max_flow_a.png" alt="red_original_updated_max_flow_a.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 17: </span>En la red original actualizamos el flujo en 2 unidades sobre el camino de <i>augmented path</i>.</p>
</div>


</section>
<section id="slide-orga1d8df3">
<h4 id="orga1d8df3">Segunda iteración</h4>
<p>
Actualizamos la red residual
</p>


<div class="figure">
<p><img src="../images/red_residual_max_flow_b.png" alt="red_residual_max_flow_b.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 18: </span>Red residual en la segunda iteración.</p>
</div>

</section>
<section>

<p>
Ahora hay dos <i>augmented path</i>: \(A \to C \to D\) y \(A \to C \to B \to D\). Tomemos
el primero. Su <i>capacidad residual</i> es <b>3</b>.
</p>


<div class="figure">
<p><img src="../images/red_residual_augmented_path_max_flow_b.png" alt="red_residual_augmented_path_max_flow_b.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 19: </span>Seleccionamos el augmented path marcado en azul. Su capacidad residual es 3.</p>
</div>

</section>
<section>

<p>
Actualizamos la red original, aumentamos en <b>3</b> el flujo del camino \(A\to
C \to D\). Todos los arcos de este camino son <i>forward arcs</i>. 
</p>


<div class="figure">
<p><img src="../images/red_original_updated_max_flow_b.png" alt="red_original_updated_max_flow_b.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 20: </span>Red original actualizada. Se agregan 3 unidades por el camino A -C - D.</p>
</div>

</section>
<section id="slide-org248952f">
<h4 id="org248952f">Tercera iteración</h4>
<p>
Actualizamos la red residual
</p>


<div class="figure">
<p><img src="../images/red_residual_max_flow_c.png" alt="red_residual_max_flow_c.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 21: </span>Red residual en la tercera iteración.</p>
</div>

</section>
<section>

<p>
Ahora sólo queda un <i>augmented path</i> \(A \to C \to B \to D\), con <i>capacidad</i>
<i>residual</i> de <b>1</b>
</p>


<div class="figure">
<p><img src="../images/red_residual_augmented_path_max_flow_c.png" alt="red_residual_augmented_path_max_flow_c.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 22: </span>En la tercera iteración de la red residual, sólo queda un camino aumentado, con capacidad residual de 1.</p>
</div>

</section>
<section>

<p>
Actualizamos la red original, aumentamos en <b>3</b> el flujo del camino \(A\to
C \to D\). Los arcos \((A,C)\) y \((B,D)\) son <i>forward arcs</i>, \((C,B)\) es un
<i>backward arc</i>. 
</p>


<div class="figure">
<p><img src="../images/red_original_updated_max_flow_c.png" alt="red_original_updated_max_flow_c.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 23: </span>Actualización de los flujos de la red original. Nota que el arco B-C se actualizó restando una unidad, ya que era un backward arc.</p>
</div>

</section>
<section>


<div class="figure">
<p><img src="../images/red_residual_max_flow_d.png" alt="red_residual_max_flow_d.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 24: </span>Red residual final. No hay augmented paths. El algoritmo se detiene aquí.</p>
</div>

</section>
<section>

<p>
Podemos ejecutar el algoritmo y comprobar nuestra solución encontrada
manualmente
</p>

<div class="org-src-container">

<pre><code class=" jupyter-python" >G = {}
G['A'] = {}
G['A']['B'] = { 'capacidad':2, 'flujo':0 }
G['A']['C'] = { 'capacidad':4, 'flujo':0 }
G['B'] = {}
G['B']['C'] = { 'capacidad':3, 'flujo':0 }
G['B']['D'] = { 'capacidad':1, 'flujo':0 }
G['C'] = {}
G['C']['D'] = {'capacidad':5, 'flujo':0}
G['D'] = {}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >ford_fulkerson(G, 'A', 'D')
</code></pre>
</div>

</section>
<section id="slide-orgffa9f2a">
<h3 id="orgffa9f2a">Ejemplo</h3>
<p>
Tomado de <a class="org-ref-reference" href="#slide-bibliography">[tahaInvestigacionOperaciones10a2017]</a>
</p>


<div class="figure">
<p><img src="../images/ford_fulkerson_example_a.png" alt="ford_fulkerson_example_a.png" width="400px" height="350px">
</p>
<p><span class="figure-number">Figure 25: </span>Red para el ejemplo del algoritmo de Ford-Fulkerson. Tomado de <a class="org-ref-reference" href="#slide-bibliography">[tahaInvestigacionOperaciones10a2017]</a></p>
</div>

</section>
<section id="slide-org6f0ff7a">
<h4 id="org6f0ff7a">Implementación en python</h4>
<div class="org-src-container">

<pre><code class=" jupyter-python" >max_flow_0 = {}
max_flow_0["1"] = {}
max_flow_0["1"]["2"] = {'flujo': 0, 'capacidad': 20}
max_flow_0["1"]["3"] = {'flujo': 0, 'capacidad': 30}
max_flow_0["1"]["4"] = {'flujo': 0, 'capacidad': 10}
max_flow_0["2"] = {}
max_flow_0["2"]["3"] = {'flujo': 0, 'capacidad': 40}
max_flow_0["2"]["5"] = {'flujo': 0, 'capacidad': 30}
max_flow_0["3"] = {}
max_flow_0["3"]["4"] = {'flujo': 0, 'capacidad': 10}
max_flow_0["3"]["5"] = {'flujo': 0, 'capacidad': 20}
max_flow_0["4"] = {}
max_flow_0["4"]["3"] = {'flujo': 0, 'capacidad': 5}
max_flow_0["4"]["5"] = {'flujo': 0, 'capacidad': 20}
max_flow_0["5"] = {}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >ford_fulkerson(max_flow_0, '1', '5')
</code></pre>
</div>


</section>
<section id="slide-org394cd23">
<h3 id="org394cd23">Ejemplo</h3>

<div class="figure">
<p><img src="file:///home/nanounanue/pCloudDrive/org/clases/operations-research/images/ford_fulkerson_example_b.png" alt="ford_fulkerson_example_b.png" width="300px" height="250px">
</p>
<p><span class="figure-number">Figure 26: </span>Red para el ejemplo del algoritmo de Ford-Fulkerson</p>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >max_flow_1 = {}
max_flow_1["A"] = {}
max_flow_1["A"]["B"] = {'flujo': 0, 'capacidad': 4}
max_flow_1["A"]["C"] = {'flujo': 0, 'capacidad': 4}
max_flow_1["B"] = {}
max_flow_1["B"]["E"] = {'flujo': 0, 'capacidad': 4}
max_flow_1["B"]["D"] = {'flujo': 0, 'capacidad': 4}
max_flow_1["C"] = {}
max_flow_1["C"]["D"] = {'flujo': 0, 'capacidad': 4}
max_flow_1["D"] = {}
max_flow_1["D"]["F"] = {'flujo': 0, 'capacidad': 4}
max_flow_1["E"] = {}
max_flow_1["E"]["F"] = {'flujo': 0, 'capacidad': 4}
max_flow_1["F"] = {}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >ford_fulkerson(max_flow_1, 'A', 'F')
</code></pre>
</div>

</section>
<section id="slide-org92e63c2">
<h3 id="org92e63c2">Ejemplo: Parque Seervada</h3>
<p>
Regresemos a la pregunta que no pudimos responder antes:
</p>

<blockquote>
<p>
En temporada alta, hay más personas que quieren ir a <b>T</b> de las que
 se les puede dar servicio. Para no perturbar/dañar el ecosistema
 del parque se han establecido límites al número de viajes que
 pueden hacerse en los tramos. ¿Cómo planear las rutas de los
 distintos viajes de manera que se <i>maximice</i> el número total de
 viajes que se pueden hacer al día?
</p>
</blockquote>



<div class="figure">
<p><img src="../images/seervada_park_2.png" alt="seervada_park_2.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 27: </span>Red de caminos del Parque Seervada. Los arcos muestran su capacidad máxima, no la distancia. Tomado de <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a></p>
</div>

</section>
<section>

<div class="org-src-container">

<pre><code class=" jupyter-python" >seervada_flow = {}
seervada_flow['O'] = {}
seervada_flow['O']['A'] = { 'flujo': 0, 'capacidad': 5 }
seervada_flow['O']['B'] = { 'flujo': 0, 'capacidad': 7 }
seervada_flow['O']['C'] = { 'flujo': 0, 'capacidad': 4 }

seervada_flow['A'] = { }
seervada_flow['A']['B'] = { 'flujo': 0, 'capacidad': 1 }
seervada_flow['A']['D'] = { 'flujo': 0, 'capacidad': 3 }

seervada_flow['B'] = { }
seervada_flow['B']['C'] = { 'flujo': 0, 'capacidad': 2 }
seervada_flow['B']['D'] = { 'flujo': 0, 'capacidad': 4 }
seervada_flow['B']['E'] = { 'flujo': 0, 'capacidad': 5 }

seervada_flow['C'] = { }
seervada_flow['C']['E'] = { 'flujo': 0, 'capacidad': 4 }

seervada_flow['D'] = { }
seervada_flow['D']['T'] = { 'flujo': 0, 'capacidad': 9 }

seervada_flow['E'] = {}
seervada_flow['E']['D'] = { 'flujo': 0, 'capacidad': 1 }
seervada_flow['E']['T'] = { 'flujo': 0, 'capacidad': 6 }

seervada_flow['T'] = {}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >ford_fulkerson(seervada_flow, 'O', 'T')
</code></pre>
</div>

</section>
<section id="slide-orgf6fee17">
<h3 id="orgf6fee17">Extensiones: Múltiples fuentes y sumideros</h3>
<p>
Supón que en el problema aparecen varias fuentes y/o varios sumideros,
por ejemplo una compañía que tiene una fábrica (<b>fuente</b>) y varios
centros de distribución (<b>sumidero</b>). Podemos resolverlo con los
algoritmos de <b>max flow</b> si agregamos dos <b>super nodos</b>: <b>super-source</b>,
\(S\) y <b>super-sink</b>, \(T\). Agregaremos varios arcos de \(S\) a todos las
fuentes originales y de todas los sumideros a \(T\). Las capacidades de
estos arcos es \(\infty\). Luego procedemos a resolverlo normalmente. 
</p>


<div class="figure">
<p><img src="../images/ford_fulkerson_example_2.png" alt="ford_fulkerson_example_2.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 28: </span>Ejemplo para problemas de flujo máximo con múltiples fuentes y múltiples sumideros.</p>
</div>

</section>
<section>


<div class="figure">
<p><img src="../images/ford_fulkerson_example_2b.png" alt="ford_fulkerson_example_2b.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 29: </span>Ejemplo para problemas de flujo máximo con múltiples fuentes y múltiples sumideros, con super nodos añadidos.</p>
</div>

</section>
<section id="slide-org21e2d2b">
<h4 id="org21e2d2b">Implementación en <code>python</code></h4>
<div class="org-src-container">

<pre><code class=" jupyter-python" >max_flow_2 = {}
max_flow_2["s"] = {}
max_flow_2["s"]["A"] = {'flujo': 0, 'capacidad': 8}
max_flow_2["s"]["B"] = {'flujo': 0, 'capacidad': 2}
max_flow_2["s"]["C"] = {'flujo': 0, 'capacidad': 9}
max_flow_2["A"] = {}
max_flow_2["A"]["D"] = {'flujo': 0, 'capacidad': 4}
max_flow_2["A"]["E"] = {'flujo': 0, 'capacidad': 4}
max_flow_2["B"] = {}
max_flow_2["B"]["E"] = {'flujo': 0, 'capacidad': 2}
max_flow_2["C"] = {}
max_flow_2["C"]["E"] = {'flujo': 0, 'capacidad': 5}
max_flow_2["C"]["F"] = {'flujo': 0, 'capacidad': 4}
max_flow_2["D"] = {}
max_flow_2["D"]["G"] = {'flujo': 0, 'capacidad': 6}
max_flow_2["E"] = {}
max_flow_2["E"]["G"] = {'flujo': 0, 'capacidad': 4}
max_flow_2["E"]["H"] = {'flujo': 0, 'capacidad': 3}
max_flow_2["F"] = {}
max_flow_2["F"]["H"] = {'flujo': 0, 'capacidad': 5}
max_flow_2["G"] = {}
max_flow_2["G"]["t"] = {'flujo': 0, 'capacidad': 10}
max_flow_2["H"] = {}
max_flow_2["H"]["t"] = {'flujo': 0, 'capacidad': 8}
max_flow_2["t"] = {}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >ford_fulkerson(max_flow_2, 's', 't')
</code></pre>
</div>

</section>
<section id="slide-orgba787f5">
<h3 id="orgba787f5">Extensiones: Capacidades en los nodos</h3>
<p>
¿Qué sucede si hay un límite en las capacidades que un nodo puede
contener? Por ejemplo, en el centro de distribución sólo caben \(k\)
camiones. Para resolverlo, dividiremos los nodos en dos: \(in-vertex\) y
\(out-vertex\), y agregaremos arcos que van del \(in-vertex\) al
\(out-vertex\). La capacidad del nodo será la capacidad del arco. Ahora
podemos aplicar el algoritmo de Ford-Fulkerson. 
</p>

</section>
</section>
<section>
<section id="slide-org7a44ccd">
<h2 id="org7a44ccd">Minimum cost flow</h2>
<form><ul>
<li>El problema del <span class="underline">flujo de costo mínimo</span>  ocupa una posición muy
importante en los algoritmos de optimización de redes, ya que abarca
una gran clase de aplicaciones.</li>
<li>Tiene similitudes con el problema del <a href="#slide-orgfaeae77" class="backwardlink">flujo máximo</a>, la red tiene
<i>capacidades</i> en sus arcos y  con el problema de la <a href="#slide-org8e0c6ff" class="backwardlink backwardlink">ruta más corta</a>
considera el costo/distancia del flujo a través del arco <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a></li>
<li>Las similitudes existen ya que esos problemas son casos especiales
del problema de <span class="underline">flujo de costo mínimo</span>.</li>

</ul></form>

</section>
<section>


<p>
El planteamiento del problema es como sigue:
</p>

<p>
Sea \(G=(N,A, u, c, b)\) una red dirigida. Para cada arco \((i,j) \in A\) asociamos una <b>capacidad</b> \(u_{ij}\), 
que especifica la cantidad máxima que puede fluir en el arco. Además cada arco \((i,j) \in A\), 
tiene asociado un <b>costo</b> \(c_{ij}\) que denota el costo por unidad de flujo en ese arco.
</p>

<p>
También asociaremos a cada nodo \(i \in N\) un número \(b_i\). Este valor representa la demanda/oferta
de cada nodo. Si \(b_i > 0\) decimos que es un <b>supply node</b>, si \(b_i < 0\) el nodo es un <b>demand node</b>. 
Si \(b_i = 0\) el nodo es un nodo de <b>trans shipment</b>.
</p>

<p>
A este tipo de red se le llama <span class="underline">red de transporte</span>.
</p>

</section>
<section>

<p>
El problema de optimización es como sigue:
</p>

<p>
Sea 
</p>
<form><ul>
<li>\(x_{ij}\) el flujo a través del arco \((i,j)\),</li>
<li>\(c_{ij}\) el costo por unidad de flujo a través del arco \((i,j)\)</li>
<li>\(u_{ij}\) la capacidad del arco \((i,j)\)</li>
<li>\(b_i\) el flujo neto generado por el nodo \(i\)</li>

</ul></form>

<p>
El objetivo es minimizar el costo total de enviar los recursos
disponibles a través de la red para satisfacer la demanda.
</p>

<div>
\begin{equation*}
\begin{aligned}
& \text{min}  
& & z(x) = \sum_{(i,j) \in A} c_{ij} x_{ij}  \\
& \text{s.t.}   \\
& & & \sum_{j:(i,j) \in A} x_{ij} - \sum_{j:(j,i) \in A} x_{ji} = b_i & \ \text{para todo} \  i \in N, \\
& & & 0 \leq x_{ij} \leq u_{ij}  & \ \text{para todo} \  (i, j) \in A
\end{aligned}
\end{equation*}

</div>

<p>
La primera restricción es conocida como <b>restricción de balance de
masa</b>, la segunda son los límites físicos del flujo.  
</p>

<p>
i.e. <i>El objetivo es minimizar el costo total de enviar el suministro</i>
   <i>disponible a través de la red para satisfacer a demanda dada</i>
</p>


</section>
<section id="slide-orgc27826f">
<h3 id="orgc27826f">Suposiciones</h3>
<form><ol>
<li>La red es dirigida y conexa</li>
<li>Todos los datos \((u, c, b)\) son enteros</li>
<li>Al menos uno de los nodos es un <i>nodo fuente</i> y al menos uno de los
nodos en un <i>nodo demanda</i>. El resto de los nodos son nodos de <i>transbordo</i>.</li>
<li>Todos los costos son no negativos</li>
<li>El flujo se permite a través de un arco, sólo en la dirección del
arco y su cantidad máxma está dada por la <i>capacidad</i> del arco.</li>
<li>Los nodos satisfacen \(\sum_{i} b_i = 0\) y el problema tiene una solución factible.</li>
<li>El costo del flujo a través del arco es <i>proporcional</i> a la cantidad
del flujo.</li>

</ol></form>

<p>
Tomados de: <a class="org-ref-reference" href="#slide-bibliography">[ahujaNetworkFlowsTheory1993]</a> y <a class="org-ref-reference" href="#slide-bibliography">[hillierINVESTIGACIONOPERACIONES2015]</a>
</p>

</section>
<section id="slide-orgd12a158">
<h3 id="orgd12a158">Casos especiales</h3>
<form><dl>
<dt>Problema de transporte</dt><dd>\(u_{ij} = \infty\), No hay nodos de transbordo</dd>

</dl></form>


<div class="figure">
<p><img src="../images/transportation_problem.png" alt="transportation_problem.png">
</p>
</div>

<form><dl>
<dt>Problema de asignación</dt><dd>\(|S| = |T|\), \(b_i = 1\) si \(i \in S\), \(b_i =
  -1\) si \(i \in T\).</dd>

<dt>Problema de transbordo</dt><dd>\(u_{ij} = \infty\)</dd>
<dt>Problema de la ruta más corta</dt><dd>El nodo \(b_s = 1\), \(b_t=-1\), \(b_i =
  0\). \(u_{ij} = \infty\)</dd>
<dt>Problema de flujo máximo</dt><dd>\(c_{ij} = 0\), un arco \((s,t)\) con \(c_{st} = M\)
y \(u_{ij} = \infty\). Asignar \(F\) muy grande a \(s\) y \(-F\) a \(t\).</dd>

</dl></form>

</section>
<section id="slide-org0d0afd7">
<h3 id="org0d0afd7">¿Cuándo tiene una solución <b>factible</b>?</h3>
<form><ul>
<li>La condición necesaria para que un problema de flujo de coste mínimo
tenga soluciones factibles es que el flujo total generado por los
nodos origen es igual al flujo total de lo absorbido por los nodos destino.</li>

</ul></form>

<p>
\[
\sum^n_{i=1} b_i = 0
\]
</p>

<form><ul>
<li>Si \(\sum_i b_i \neq 0\), no hay solución ya que se violan la restricción de balance de masa.
<form><ul>
<li>Si este es el caso, se puede agregar un nodo \(r\) que sea tenga \(b_r =  -\delta\)</li>
<li>Aún con \(\delta = 0\) no es seguro que tenga solución.</li>

</ul></form></li>

<li>Para ver si tiene solución, agreguemos dos nodos \(s, t\) a la
red. Para cada nodo \(i \in N\) con \(b_i > 0\) agregamos un arco \((s,i)\)
con capacidad \(b_i\) y costo \(0\). Para cada nodo \(i \in N\) con \(b_i < 0\)
agregamos un arco \((i,t)\) con capacidad \(-b_i\) y costo \(0\). A esta
red se le conocde como <b>red transformada</b></li>

</ul></form>


</section>
<section id="slide-org51187fe">
<h3 id="org51187fe">Ejemplo</h3>

<div class="figure">
<p><img src="../images/min_cost_flow_example.png" alt="min_cost_flow_example.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 31: </span>Red original para el ejemplo del min cost flow problem</p>
</div>


<p>
<i>Ejercicio</i>
</p>

<form><ul>
<li>Crea una función llamada <code>transformed_network(G)</code> que genere el grafo transformado</li>
<li>Crear una función llamada <code>feasible_min_cost_solution(G)</code> que
devuelva <code>True</code> si el grafo <code>G</code> tiene una solución <i>factible</i>.</li>

</ul></form>

</section>
<section>

<p>
Como referencia, la <span class="underline">red transformada</span> es:
</p>


<div class="figure">
<p><img src="file:///home/nanounanue/pCloudDrive/org/clases/operations-research/images/transformed_network_min_cost_flow_example.png" alt="transformed_network_min_cost_flow_example.png" width="500px" height="500px">
</p>
<p><span class="figure-number">Figure 32: </span>Red transformada para el ejemplo de min cost flow problem</p>
</div>

</section>
<section>

<p>
La solución factible, tiene una <b>red residual</b> (después de remover los
nodos \(s\) y \(t\) y todos sus arcos), a la que 
denotaremos como \(G_x = (N, A_x)\), donde \(A_x\) son los arcos de la red
residual de la solución factible con flujo \(x\). 
</p>


<p>
Nota que en esta red la unidad que fluyan de \(i\) a \(j\) en el arco
\((i,j)\) incrementan la función objetivo en \(c_{ij}\), y si fluye de \(j\) a
\(i\) decrementa la función objetivo en \(c_{ij}\). 
</p>


<p>
<i>Ejercicio</i>
Modifica el método <code>residual_network</code> para tomar en cuenta los costos
¿Cuál es la red residual de la solución factible de la red del
ejercicio anterior?
</p>

</section>
<section>

<p>
La <span class="underline">red residual de la solución factible</span> de la red del ejemplo es:
</p>


<div class="figure">
<p><img src="file:///home/nanounanue/pCloudDrive/org/clases/operations-research/images/residual_network_min_cost_flow_example.png" alt="residual_network_min_cost_flow_example.png" width="500px" height="350px">
</p>
<p><span class="figure-number">Figure 33: </span>Red residual para el ejemplo de min cost flow problem</p>
</div>

</section>
<section id="slide-orgb241ebe">
<h3 id="orgb241ebe">¿Cómo lo solucionamos?</h3>
<p>
Existen varios algoritmos para solucionar este problema, pero los más
importantes son:
</p>

<form><ul>
<li><i>Cycle cancelling algorithm</i></li>

<li><i>Sucessive Shortest path algorithm</i></li>

</ul></form>

</section>
<section id="slide-org0da90f5">
<h3 id="org0da90f5">Algoritmo de cancelación de ciclos</h3>
<form><dl>
<dt>Teorema 1 (Existencia de la solución)</dt><dd>Sea \(G\) una red de
transporte. Supongamos que \(G\) no contiene ciclos negativos sin
capacidad (i.e. un ciclo consistente en arcos \((i,j)\) con \(u_{ij} = \infty\))
y que existe una solución factible del problema de flujo de costo
mínimo. Entonces la solución óptima existe.</dd>

</dl></form>

<p>
<i>Prueba</i> Dado que el problema del flujo de costo mínimo es un caso
especial de programación lineal. Si el problema de programación lineal
tiene una solución factible y su función objetivo está acotada,
entonces tiene una solución óptima. Si \(G\) no tiene ciclos  negativos
sin capacidad entonces la función objetivo está acotada por abajo,
entonces la solución óptima existe. 
</p>

</section>
<section>

<form><dl>
<dt>Teorema 2 (Condiciones de optimalidad)</dt><dd>Sea \(x^*\) una solución
factible del problema de flujo de costo mínimo. Entonces \(x^*\) es una
solución óptima si y sólo si, la red  residual \(G_x\) no contiene
ciclos dirigidos de costos negativos.</dd>

</dl></form>

</section>
<section>

<p>
Este último teorema nos da el algoritmo de cancelación de ciclos:
</p>

<pre class="example">
algoritmo cycle_cancelling
    G_x &lt;- encuentra un flujo factible x en la red # Usando ford-fulkerson
    Mientas G_x contenga un ciclo negativo
        W &lt;- identifica el ciclo negativo  # usando bellman-ford
        d &lt;- min{r_ij: (i,j) en W}
        aumenta en d unidades el flujo alrededor de W
        actualiza G_x
    regresa G_x
</pre>


</section>
<section id="slide-lectures/Networks/Bellman-Ford">
<h4 id="lectures/Networks/Bellman-Ford">Algoritmo Bellman Ford</h4>
<p>
¿Cómo identifico los ciclos negativos?
</p>

<p>
¿Recuerdas que mencionamos el algoritmo de <span class="underline">Bellman Ford</span> cuando vimos
<i>shortest path problem</i>? Este algoritmo detecta los ciclos negativos (y
resuelve el problema de ruta más corta). 
</p>

</section>
<section>
<ul class="org-ul">
<li><a id="org97d535f"></a>Comparación con Dijkstra<br>
<form><ul>
<li>Ambos calculan el camino más corto de <span class="underline">un</span> nodo a <span class="underline">todos</span> los demás nodos</li>
<li>Trabaja con pesos negativos en los arcos</li>
<li>Pero ninguno trabaja con ciclos negativos</li>
<li>Dijkstra es <i>greedy</i>, Bellman-Ford <b>no</b> lo es <i>greedy</i>.
<form><ul>
<li>No seleccionamos un nodo, actualizamos <i>todos</i> los nodos</li>

</ul></form></li>

</ul></form>

</section>
<section>
</li>
<li><a id="org5637846"></a>Observación clave de Bellman-Ford<br>
<form><ul>
<li>Hay un máximo de \(|N| - 1\) arcos en cada uno de los <i>paths</i></li>

<li>Si hay más arcos, significa que hay un <span class="underline">ciclo</span>.</li>

<li>\(|N|\) o más arcos en un camino \(\implies\) un nodo está repetido en el
camino \(\implies\) hay un <span class="underline">ciclo</span></li>

</ul></form>

</section>
<section>
</li>
<li><a id="org775ba3a"></a>Pseudoalgoritmo<br>
<p>
En su forma original, el algoritmo es el siguiente:
</p>

<pre class="example">
     algoritmo bellman_ford ( G, costs, source, target )
           d[i] = infinity para todos los nodos i en N
           d[source] &lt;- 0
           pred[source] &lt;- None
           n &lt;- número de nodos, i &lt;- 0
           # Iteración de 1 a n-1
           mientras i &lt; (n - 1)
              para cada nodo en G
                  para cada vecino de nodo
                       relax(nodo, vecino)
           d_prev &lt;- d
           
           # Iteración n
           # Detección de ciclos negativos
           para cada nodo en G
              para cada vecino de nodo
                   relax(nodo, vecino)

            si d_prev &lt;&gt; d
                # Ciclos negativos detectados
                # No hay solución al SPP
                pred &lt;- None
                d &lt;- None
</pre>

<p>
Donde la función <code>relax</code> es:
</p>

<pre class="example">
    relax(nodo, vecino)
        si d[vecino] &gt; d[nodo] + costo[nodo][vecino]
            d[vecino] &gt; d[nodo] + costo[nodo][vecino]
            pred[vecino] = nodo
</pre>


</section>
<section>
</li>
<li><a id="org275793e"></a>Ejemplo<br>
<div class="figure">
<p><img src="../images/bellman_ford_1.png" alt="bellman_ford_1.png">
</p>
<p><span class="figure-number">Figure 34: </span>Ejemplo para Bellman-Ford</p>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >network = {}
network['S'] = {}
network['S']['A'] = {'costo' : 3}
network['A'] = {}
network['A']['B'] = {'costo' : 5}
network['B'] = {}
network['B']['C'] = {'costo' : -2}
network['C'] = {}
network['C']['D'] = {'costo' : 1}
network['D'] = {}
</code></pre>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >bellman_ford(network, 'S', 'D')
</code></pre>
</div>

<pre class="example">
: {'predecesores': {'S': None, 'A': 'S', 'B': 'A', 'C': 'B', 'D': 'C'},
:  'scores': {'S': 0, 'A': 3, 'B': 8, 'C': 6, 'D': 7},
:  'negative_cycles': []}
</pre>


</section>
<section>
</li>
<li><a id="org83f18b3"></a>Ejemplo<br>
<div class="figure">
<p><img src="../images/bellman_ford_2.png" alt="bellman_ford_2.png">
</p>
<p><span class="figure-number">Figure 35: </span>Segundo ejemplo para Bellman-Ford</p>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >network = {}
network['S'] = {}
network['S']['A'] = {'costo' : 10}
network['S']['E'] = {'costo' : 8}
network['A'] = {}
network['A']['C'] = {'costo' : 2}
network['B'] = {}
network['B']['A'] = {'costo' : 1}
network['C'] = {}
network['C']['B'] = {'costo' : -2}
network['D'] = {}
network['D']['A'] = {'costo' : -4}
network['D']['C'] = {'costo' : -1}
network['E'] = {}
network['E']['D'] = {'costo' : 1}
</code></pre>
</div>


<div class="org-src-container">

<pre><code class=" jupyter-python" >bellman_ford(network, 'S', 'B')
</code></pre>
</div>

<pre class="example">
: {'predecesores': {'S': None, 'A': 'D', 'E': 'S', 'C': 'A', 'B': 'C', 'D': 'E'},
:  'scores': {'S': 0, 'A': 5, 'B': 5, 'C': 7, 'D': 9, 'E': 8},
:  'negative_cycles': []}
</pre>
</section>
<section>
</li>
<li><a id="org0ca29e3"></a>Ejemplo (con ciclos negativos)<br>
<div class="org-src-container">

<pre><code class=" jupyter-python" >network = {}
network['S'] = {}
network['S']['A'] = {'costo' : 10}
network['S']['E'] = {'costo' : 8}
network['A'] = {}
network['A']['C'] = {'costo' : -20}
network['B'] = {}
network['B']['A'] = {'costo' : 1}
network['C'] = {}
network['C']['B'] = {'costo' : -2}
network['D'] = {}
network['D']['A'] = {'costo' : -4}
network['D']['C'] = {'costo' : -1}
network['E'] = {}
network['E']['D'] = {'costo' : 1}
</code></pre>
</div>

<div class="org-src-container">

<pre><code class=" jupyter-python" >bellman_ford(network, 'S', 'B')
</code></pre>
</div>

<pre class="example">
: {'predecesores': {},
:  'scores': {},
:  'negative_cycles': [[('B', 'A'), ('C', 'B'), ('A', 'C')]]}
</pre>
</li>
</ul>



</section>
<section id="slide-orgb469eef">
<h4 id="orgb469eef">Ejemplo</h4>

<div class="figure">
<p><img src="../images/cycle_cancelling_1.png" alt="cycle_cancelling_1.png">
</p>
<p><span class="figure-number">Figure 36: </span>Ejemplo para el algoritmo de cancelación de ciclos</p>
</div>


</section>
<section id="slide-org5530a7a">
<h3 id="org5530a7a">Algoritmo <i>Successive Shortest path</i></h3>
<p>
El algoritmo de cancelación de ciclos mantiene la factibilidad de la
solución en cada paso mientras trata de buscar el la solución óptima. 
</p>

<p>
El algoritmo de <i>successive shortest path</i> mantiene la optimalidad (ver
<span class="underline">Teorema 3</span> más abajo) en cada paso, mientras trata de alcanzar la
factibilidad, es decir en cada paso no cumple con las restricciones de
balance de masa. 
</p>

</section>
<section>

<p>
Recuerda la condición para que un camino más corto sea óptima
(<b>condición de "optimalidad"</b> -la verdad no sé si esto sea una palabra
en español) es: 
</p>

<p>
\[
d(j) \leq d(i) + c_{ij}
\]
</p>

<p>
La cual puede escribirse, acomodando términos como sigue:
</p>

<p>
\[
c_{ij}^d = c_{ij} + d(i) - d(j) \geq 0
\]
</p>

</section>
<section>

<p>
Siguiendo esto, definimos las siguientes dos cantidades:
</p>

<form><dl>
<dt>Node potential</dt><dd>Para cada nodo \(i \in N\) agreguemos un número \(\pi_i\),
al que llamaremos <b>potencial del nodo</b> \(i\).</dd>

</dl></form>

</section>
<section>

<form><dl>
<dt>Costo reducido del nodo</dt><dd>El costo reducido \(c_{ij}^\pi\) del nodo \(i
  \in N\) quedará definido a partir del potencial del nodo como sigue:</dd>

</dl></form>

<p>
\[
c_{ij}^\pi = c_{ij} + \pi_i - \pi_j
\]
</p>

<p>
El costo reducido del nodo (<b>reduced cost</b>) también lo definiremos en la
red residual, justo como le hicimos con el costo antes (i.e. si el
arco es  <b>backwards</b> es costo reducido en  \(G_r\) es el negativo del costo en \(G\))
</p>

<p>
El costo reducido cumple con las siguientes propiedades:
</p>

<form><ul>
<li>Para cada camino dirigido \(P\) de \(k\) a \(l\) con \(k,l \in N\), se
tiene que  \(\sum_{(i,j) \in P} C_{ij}^\pi = \sum_{(i,j) \in P} C_{ij} - \pi(k) +
     \pi(l)\)</li>
<li>Para cada siclo dirigido \(W\), se cumple que \(\sum_{(i,j) \in W} C_{ij}^\pi =
     \sum_{(i,j) \in W} C_{ij}\)</li>

</ul></form>

<p>
Esta propiedad implica que los <i>node potentials</i>  <span class="underline">no</span> cambian el camino
más corto entre cualquier par de nodos \(k\) y \(l\) (ya que \(\pi(l) - \pi(k)\)
es constante). También, estas propiedades implican que si \(W\) es un
ciclo negativo con respecto a \(c_{ij}\) , también es un ciclo negativo
respecto a \(c_{ij}^\pi\). 
</p>

</section>
<section>

<form><dl>
<dt>Pseudoflujo</dt><dd>Un <b>pseudoflujo</b> \(x: A \to \mathbf{R}^+\) satisface
únicamente las restricciones de capacidad y de no-negatividad.</dd>

</dl></form>

</section>
<section>

<form><dl>
<dt>Desbalance del nodo \(i\)</dt><dd>Definimos como <b>desbalance del nodo</b> \(i\) la siguiente cantidad, \(e(i)\)</dd>

</dl></form>

<p>
\[
e(i) = b(i) + \sum_{j:(j,i) \in A} x_{ji} - \sum_{j:(i,j) \in A} x_{ij}
\]
</p>

<p>
Si esta cantidad es estrictamente positiva, diremos que \(i\) es un nodo
con exceso, si es estrictamente negativa, \(-e(i)\) es el <b>déficit</b> del
nodo, y si \(e(i) = 0\) diremos que el nodo está <b>balanceado</b>. 
</p>

<p>
Usando \(e(i)\) definimos a los conjuntos \(E\) y \(D\) como los conjuntos
conformados con nodos con exceso y nodos on déficit, respectivamente. 
</p>

<p>
Como \(\sum_{i \in N} e(i) = \sum_{i \in N} b(i)\), se tiene que \(\sum_{i \in E}
e(i) = - \sum_{i \in D} e(i)\) 
</p>

</section>
<section>

<p>
<span class="underline">Teorema 3</span> Una solución factible \(x^*\) es una sólución <b>óptima</b> del
problema de flujo de costo mínimo si y sólo si un conjunto de
potenciales de nodo \(\pi\) satisface la siguiente condición reducida de
optimalidad 
</p>

<p>
\[
c_{ij}^\pi \geq 0 \qquad \text{para todo arco} \quad (i,j) \in G(x^*)
\]
</p>

<p>
Esta es la condición de <b>optimalidad</b> que mantiene el algoritmo en cada paso.
</p>

</section>
<section>

<p>
<i>Lema 1</i> Supón que el pseudoflujo \(x\) satisface la cóndición reducida
de optimalidad con respecto a algunos potenciales \(\pi\). Sea \(d\) el
vector que representa los caminos más cortos de algún nodo \(s\) a todos
los demás nodos en la red residual de \(G(x)\) con \(c_{ij}^\pi\) como el
costo del arco \((i,j)\), entonces: 
</p>

<form><ul>
<li>El pseudoflujo \(x\) también satisface las condiciones de
optimalidad reducidas con respecto a los potenciales de nodo \(\pi'
     = \pi - d\).</li>
<li>Los costos reducidos, \(c_{ij}^\pi\), son cero para todos los arcos
\((i,j)\) en los caminos más cortos desde \(s\) a todos los otros
nodos.</li>

</ul></form>

</section>
<section>
<p>
<i>Lema 2</i> Supón que el pseudoflujo \(x\) satisface las condiciones de
 optimalidad reducidas. Si definimos \(x'\) a partir de \(x\) mandando
 flujo a lo largo del camino más corto de  \(s\) a algún nodo \(k\),
 entonces \(x'\) también satisface las condiciones de optimalidad
 reducidas. 
</p>

</section>
<section>

<p>
Usando estos lemas y teoremas, podemos enunciar el algoritmo:
</p>

<pre class="example">
    algoritmo ssp
        x &lt;- 0; pi &lt;- 0
        e(i) = b(i)
        E = {i: e(i) &gt; 0}; D = {i: e(i) &lt; 0}
        while E:
           - Selecciona k en E, l en D
           - Determina el camino más corto, d(j), desde k a todo los nodos en la red residual de G(x) con respecto al costo reducido c_ij^pi
           - Sea P el camino más corto entre k y l
           - pi &lt;- pi - d
           - delta &lt;- min [ e(k),  -e(l), min[r_ij: (i,j) en P]]
           - Aumenta delta unidades el flujo a lo largo del camino P
           - Actualiza x, G(x), E, D y los costos reducidos
        regresa G(x) 
</pre>


</section>
</section>
<section>
<section id="slide-orge7b843d">
<h2 id="orge7b843d">Repaso</h2>
</section>
</section>
</div>
</div>
Adolfo De Unánue
<script src="https://revealjs.com/js/reveal.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c',
rollingLinks: true,
keyboard: true,
mouseWheel: false,
fragmentInURL: false,
hashOneBasedIndex: false,
pdfSeparateFragments: true,

overview: true,
width: 1400,
height: 1000,
margin: 0.10,
minScale: 1.00,
maxScale: 1.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'fade', // see README of reveal.js for options
transitionSpeed: 'fast',
controlsTutorial: false, controlsLayout: 'edges',

// Optional libraries used to extend reveal.js
dependencies: [
{ src: 'https://revealjs.com/plugin/audio-slideshow/audio-slideshow.js', condition: function( ) { return !!document.body.classList && !Reveal.isSpeakerNotes(); } },
{ src: 'https://revealjs.com/plugin/anything/anything.js' },
{ src: 'https://revealjs.com/plugin/toc-progress/toc-progress.js', async: true, callback: function() { toc_progress.initialize('reduce', 'rgba(120,138,130,0.2)'); toc_progress.create(); } },
{ src: 'https://revealjs.com/plugin/jump/jump.js', async: true },
{ src: 'https://revealjs.com/plugin/quiz/js/quiz.js', async: true, callback: function() { prepareQuizzes({preventUnanswered: true, skipStartButton: true}); } },
{ src: 'https://revealjs.com/plugin/coursemod/coursemod.js', async: true },
{ src: 'https://revealjs.com/plugin/accessibility/helper.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'https://revealjs.com/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: 'https://revealjs.com/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'https://revealjs.com/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }]

,audioStartAtFragment: true,
  audio: {
    advance: -1, autoplay: false, defaultDuration: 0, defaultAudios: false, playerOpacity: 0.8, playerStyle: 'position: fixed; bottom: 9.5vh; left: 0%; width: 30%; height:30px; z-index: 33;' },
anything: [
        // Following initialization code for class animate from anything-demo.html.
        // Copyright (c) 2016 Asvin Goel, under The MIT License (MIT).
	{className: "animate",  initialize: (function(container, options){
		Reveal.addEventListener( 'fragmentshown', function( event ) {
			if (typeof event.fragment.beginElement === "function" ) {
				event.fragment.beginElement();
			}
		});
		Reveal.addEventListener( 'fragmenthidden', function( event ) {
			if (event.fragment.hasAttribute('data-reverse') ) {
				var reverse = event.fragment.parentElement.querySelector('[id=\"' + event.fragment.getAttribute('data-reverse') + '\"]');
				if ( reverse && typeof reverse.beginElement === "function" ) {
					reverse.beginElement();
				}
			}
		});
		if ( container.getAttribute("data-svg-src") ) {
			var xhr = new XMLHttpRequest();
			xhr.onload = function() {
				if (xhr.readyState === 4) {
					var svg = container.querySelector('svg');
					container.removeChild( svg );
					container.innerHTML = xhr.responseText + container.innerHTML;
					if ( svg ) {
						container.querySelector('svg').innerHTML = container.querySelector('svg').innerHTML + svg.innerHTML;
					}
				}
				else {
					console.warn( "Failed to get file. ReadyState: " + xhr.readyState + ", Status: " + xhr.status);
				}
			};
			xhr.open( 'GET', container.getAttribute("data-svg-src"), true );
			xhr.send();
		}
	}) },
	{className: "randomPic",
	 defaults: {imgalt: "Dummy alt text",
		    imgcaption: "Image by {name}",
		    choices: [ {name: "dummyname", path: "dummypath"} ]},
	 initialize: (function(container, options){
	     var choice = Math.trunc( Math.random()*(options.choices.length) );
	     var img = "<img src='" + options.choices[choice].path + "' alt='" + options.choices[choice].imgalt + "' />";
	     var caption = options.imgcaption.replace(new RegExp('\{name\}', 'gm'), options.choices[choice].name);
	     container.innerHTML = img + caption;
	 }) },
	{className: "notes",
	 initialize: (function(container, options){
	     container.addEventListener('click', function(e) { RevealNotes.open(); });
	 }) }
],
coursemod: { enabled: true, shown: false },
});
</script>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>
<script>
/* Recompute layout upon changes by klipse.  Code fragment from
   asciidoctor-revealjs-klipse by Timothy Pratley under GPLv3:
   https://github.com/timothypratley/asciidoctor-revealjs-klipse/blob/master/docs/docinfo-footer.html */
Reveal.addEventListener( 'slidechanged', function( event ) {
    window.dispatchEvent( new Event('resize') );
} );
</script>
</body>
</html>
